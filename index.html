<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Spring-学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-11-06T13:49:30.000Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Spring学习笔记</strong></p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h2><p>Spring 春天，给软件行业带来了春天</p>
<p>2002年的时候，首次推出了框架的雏形</p>
<p>2004年3月24日诞生</p>
<p>Rod Johnson 悉尼大学的音乐学专业博士，“轮子理论”不要重复的造轮子</p>
<p>spring理念</p>
<p>保持强大的向后兼容性，使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！</p>
<p>ssh：strus2 + spring + hibernate</p>
<p>ssm:springmvc + spring + mybabits</p>
<h2 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a><strong>2.优点</strong></h2><p>开源的免费容器</p>
<p>spring是一个轻量级的非入侵式的框架</p>
<p>控制反转 面向切面编程 支持事务的处理，对框架整合的支持</p>
<p>总结一句话：spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架</p>
<h2 id="3-组成"><a href="#3-组成" class="headerlink" title="3. 组成"></a><strong>3. 组成</strong></h2><h3 id="3-1-IOC本质"><a href="#3-1-IOC本质" class="headerlink" title="3.1 IOC本质"></a><strong>3.1 IOC本质</strong></h3><h4 id="3-1-1-什么是IOC？"><a href="#3-1-1-什么是IOC？" class="headerlink" title="3.1.1 什么是IOC？"></a><strong>3.1.1 什么是IOC？</strong></h4><p>（1）控制反转，把对象创建和对象之间的调用过程，交给spring来进行 管理</p>
<p>（2）使用IOC目的，为了耦合度降低</p>
<h4 id="3-1-2-IOC底层原理"><a href="#3-1-2-IOC底层原理" class="headerlink" title="3.1.2 IOC底层原理"></a><strong>3.1.2 IOC底层原理</strong></h4><p>（1）xml解析、工厂模式、反射</p>
<p>控制反转IoC(Inversion of Control)，是一种设计思想，DI（依赖注入）是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法，没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓的控制反转就是：获得依赖对象的方式反转了。</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106214955591.png" alt="img"></p>
<p>通过工厂模式降低了dao和service的耦合度</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215000060.png" alt="img"></p>
<h4 id="3-1-3-IOC的实现过程"><a href="#3-1-3-IOC的实现过程" class="headerlink" title="3.1.3 IOC的实现过程"></a><strong>3.1.3 IOC的实现过程</strong></h4><p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215004862.png" alt="img"></p>
<h4 id="3-1-4-IOC接口"><a href="#3-1-4-IOC接口" class="headerlink" title="3.1.4 IOC接口"></a><strong>3.1.4 IOC接口</strong></h4><p>1、IOC思想基于IOC容器完成，IOC底层就是对象工厂</p>
<p>2、Spring提供IOC容器实现两种方式：两个接口</p>
<p>（1）BeanFactory:IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用。和下面ApplicationContext的区别：加载配置文件的时候不会创建对象，在使用对象的时候才会去创建对象</p>
<p>(2)ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用，加载配置文件的时候就会把在配置文件对象进行创建</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215008870.png" alt="img"></p>
<p>实现类</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215012409.png" alt="img"></p>
<h4 id="3-1-5-IOC操作Bean管理"><a href="#3-1-5-IOC操作Bean管理" class="headerlink" title="3.1.5 IOC操作Bean管理"></a><strong>3.1.5 IOC操作Bean管理</strong></h4><p>Bean管理指的是两个操作（1）Spring创建对象 （2）Spring注入属性</p>
<p>Bean管理操作有两种方式</p>
<p>（1）基于xml配置文件方式实现</p>
<p>（2）基于注解方式实现</p>
<h5 id="3-1-5-1-IOC操作Bean管理（基于xml方式）"><a href="#3-1-5-1-IOC操作Bean管理（基于xml方式）" class="headerlink" title="3.1.5.1  IOC操作Bean管理（基于xml方式）"></a><strong>3.1.5.1  IOC操作Bean管理（基于xml方式）</strong></h5><p>1、基于xml方式创建对象</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215017691.png" alt="img"></p>
<p>（1）在spring配置文件中，使用bean标签，标签里面添加对应属性，据可以实现对象创建</p>
<p>（2）在bean标签里有很多属性，介绍常用的属性</p>
<p>id属性：获取对象的唯一的标识</p>
<p>class属性：创建对象的全路径（包和类的路径）</p>
<p>（3）创建对象时候，默认也是执行无参数的构造方法完成对象的创建</p>
<p>2、基于xml方式注入属性</p>
<p>（1）DI：依赖注入，就是注入属性，在创建对象的基础上进行完成</p>
<p>第一种注入方法：使用set方法进行注入</p>
<p>（1）创建一个类，定义属性和对应的set方法</p>
<p>（2）在spring配置文件中，配置对象创建，配置属性注入</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215021341.png" alt="img"></p>
<p>第二种注入方式：使用有参数的构造进行注入</p>
<p>（1）创建类，定义属性，创建属性对应的有参数构造方法</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215025208.png" alt="img"></p>
<p>（2）在spring配置文件中进行配置</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215029004.png" alt="img"></p>
<p>5、p名称空间注入</p>
<p>（1）使用p名称空间注入，可以简化基于xml配置方式</p>
<p>第一步：添加p名称空间注入，可以简化基于xml配置的方式</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215032790.png" alt="img"></p>
<p>第二步：进行属性注入，在bean标签里面进行操作</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215035789.png" alt="img"></p>
<p>IOC操作Bean管理（FactoryBean）</p>
<p>1、spring有两种类型Bean，一种普通bean，另外一种工厂bean（FactoryBean）</p>
<p>2、普通bean:在配置文件中，定义bean类型就是返回类型</p>
<p>3、工厂bean：在配置文件定义bean类型可以和返回类型不一样</p>
<p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p>
<p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215038865.png" alt="img"></p>
<h5 id="3-1-5-2IOC操作Bean管理（基于注解方式）"><a href="#3-1-5-2IOC操作Bean管理（基于注解方式）" class="headerlink" title="3.1.5.2IOC操作Bean管理（基于注解方式）"></a><strong>3.1.5.2IOC操作Bean管理（基于注解方式）</strong></h5><p>1、什么是注解</p>
<p>（1）注解是代码特殊标记，格式：@注解名称（属性名称&#x3D;属性值，属性名称&#x3D;属性值）</p>
<p>（2）使用注解，注解作用在类上面，方法上面，属性上面</p>
<p>（3）使用注解配置：简化xml配置</p>
<p>2、Spring针对Bean中创建对象提供注解</p>
<p>（1）@Component:spring容器中提供的一种普通注解</p>
<p>(2)@Service：一般用在业务逻辑层、service层</p>
<p>(3)@Controller：用在web层</p>
<p>(4)@Repository：用在dao层</p>
<p>上面的注解功能是一样的，都可以用来创建对象，用在不同的层中，让开发人员更加清晰当前组件所扮演的角色</p>
<p>3、基于注解方式实现对象的创建</p>
<p>第一步：引入aop的依赖</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215050439.png" alt="img"></p>
<p>第二步：开启组件扫描</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215053140.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215057870.png" alt="img"></p>
<p>第三步：创建类，在类上加上注解</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215104498.png" alt="img"></p>
<p>4、开启组件扫描细节配置</p>
<p>扫描带有Controller注解的类扫描</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215108369.png" alt="img"></p>
<p>不扫描带有Controller注解的类</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215111908.png" alt="img"></p>
<p>基于注解方式实现属性注入</p>
<p>（1）@AutoWired</p>
<p>根据属性类型进行自动注入</p>
<p>第一步：把service和dao对象进行创建，在service和dao类添加创建对象注解</p>
<p>第二步：在service里面注入dao对象，在service类里面添加dao类型的属性，在属性上面使用注解做到</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215116557.png" alt="img"></p>
<p>（2）@Qualiier</p>
<p>根据属性名称进行注入，这个注解的使用，需要和@AutoWired一起使用，如果一个接口多个实现类就需要根据名称找到到底是哪一个</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215120188.png" alt="img"></p>
<p>(3)@Resourse</p>
<p>可以根据类型注入，可以根据名称注入。这个注解是javax包里面的，不是spring官方提供的</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215126552.png" alt="img"></p>
<p>（4）@Value</p>
<p>注入普通类型</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215129688.png" alt="img"></p>
<h3 id="3-2-AOP"><a href="#3-2-AOP" class="headerlink" title="3.2 AOP"></a><strong>3.2 AOP</strong></h3><p>什么是AOP?</p>
<p>（1）AOP是面向切面编程（面向方面编程），AOP是OOP的延续，可以对业务对各部分尽心隔离，使业务逻辑各部分之间的耦合度降低，提高程序的可重用性。</p>
<p>（2）通俗描述：不通过修改源代码的方式，在主干添加功能。</p>
<p>（3）使用登陆的例子来说明AOP</p>
<p>用登陆实例讲解什么是AOP</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215133439.png" alt="img"></p>
<h3 id="3-3-AOP的底层原理"><a href="#3-3-AOP的底层原理" class="headerlink" title="3.3 AOP的底层原理"></a><strong>3.3 AOP的底层原理</strong></h3><p>1、AOP的底层使用动态代理，用动态代理的方式来进行实现增加新的功能</p>
<p>（1）有两种情况的动态代理</p>
<p>第一种：有接口的情况，使用JDK动态代理</p>
<p>创建有接口实现类的代理对象，然后通过代理对象增强登陆实现类的方法，让登陆里面加一些新的功能。</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215136763.png" alt="img"></p>
<p>第二种：动态代理没有接口的情况，使用CGLIB动态代理</p>
<p>创建子类的代理对象，增强类里面的方法</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215140288.png" alt="img"></p>
<h4 id="AOP-JDK动态代理"><a href="#AOP-JDK动态代理" class="headerlink" title="AOP(JDK动态代理)"></a><strong>AOP(JDK动态代理)</strong></h4><p>1、使用JDK动态代理，使用Proxy里面的方法创建对象</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215143238.png" alt="img"></p>
<p>调用newProxyInstance方法</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215146548.png" alt="img"></p>
<p>方法里面有三个参数</p>
<p>第一个参数，类加载器</p>
<p>第二个参数，增强方法所在的类，这个类实现的接口，支持多个接口</p>
<p>第三个参数，实现这个接口InvocationHandler，创建代理对象，写增强的方法</p>
<h5 id="2、JDK动态代理的编码"><a href="#2、JDK动态代理的编码" class="headerlink" title="2、JDK动态代理的编码"></a><strong>2、JDK动态代理的编码</strong></h5><p>（1）创建接口，定义方法</p>
<p>（2）创建接口的实现类，实现方法</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215150146.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215153413.png" alt="img"></p>
<p>（3）使用Proxy</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215156346.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215201337.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215205318.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215208539.png" alt="img"></p>
<h3 id="3-4-AOP-术语"><a href="#3-4-AOP-术语" class="headerlink" title="3.4 AOP(术语)"></a><strong>3.4 AOP(术语)</strong></h3><p>1、连接点</p>
<p>类里面哪些方法可以被增强，这些方法称为连接点</p>
<p>2、切入点</p>
<p>实际被真正增强的方法，称为切入点</p>
<p>3、通知（增强）</p>
<p>（1）实际增强的逻辑部分称为通知（增强），就是比如登陆里面加权限判断</p>
<p>（2）通知有多种类型：</p>
<p>前置通知</p>
<p>后置通知</p>
<p>环绕通知</p>
<p>异常通知</p>
<p>最终通知 finally</p>
<p>4、切面</p>
<p>是动作操作，把通知应用到切入点的过程称之为通知</p>
<p>（1）把通知应用到切入点的过程，把权限判断加到登陆里面的过程</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215213138.png" alt="img"></p>
<h3 id="3-5-AOP的操作"><a href="#3-5-AOP的操作" class="headerlink" title="3.5 AOP的操作"></a><strong>3.5 AOP的操作</strong></h3><p>1、在Spring中基于AspectJ实现AOP操作</p>
<p>（1）什么是AspectJ</p>
<p>AspectJ不是Spring的组成部分，独立的AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</p>
<p>2、基于AspectJ实现AOP操作</p>
<p>（1）基于xml配置文件实现</p>
<p>（2）基于注解方式实现</p>
<p>3、在项目工程里面引入AOP相关依赖</p>
<p>4、切入点表达式</p>
<p>（1）切入点表达式的作用：知道要对哪个类对哪个方法进行增强</p>
<p>（2）语法结构</p>
<p>ececution([权限修饰符][返回类型][类全路径][方法名][参数列表])</p>
<p><img src="https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcADXW0lcmHPWbcohLK37rVox:3335998147484307025fcADXW0lcmHPWbcohLK37rVox:1667744324479" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215218147.png" alt="img"></p>
<h3 id="3-6-AOP方式（AspectJ注解）"><a href="#3-6-AOP方式（AspectJ注解）" class="headerlink" title="3.6 AOP方式（AspectJ注解）"></a><strong>3.6 AOP方式（AspectJ注解）</strong></h3><p>1、创建类，在类里面定义方法，实现对类中方法的增强</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215221038.png" alt="img"></p>
<p>2、创建增强类（编写增强逻辑）</p>
<p>（1）在增强类里面创建方法，不同的方法创建不同的通知类型</p>
<p>3、进行通知的配置</p>
<p>（1）在spring配置文件中，开启注解扫描</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215223936.png" alt="img"></p>
<p>（2）使用注解创建User和UserProxy对象</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215227192.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215240837.png" alt="img"></p>
<p>（3）在增强类上面添加注解@Aspect</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215243338.png" alt="img"></p>
<p>（4）在Spring配置文件中开启生成代理对象</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215246602.png" alt="img"></p>
<p>4、配置不同类型的通知</p>
<p>（1）在增强类的里面，在作为通知的方法上面添加通知类型注解，使用切入点表达式配置</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215249795.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215252636.png" alt="img"></p>
<p>有异常才会执行</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215255617.png" alt="img"></p>
<p>after（最终通知）不管有没有异常都执行，而afterreturnning（后置通知、返回通知）有异常就不执行。</p>
<p>5、相同的切入点抽取</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215259344.png" alt="img"></p>
<p>6、有多个增强类对同一个方法进行增强，设置增强类的一个优先级</p>
<p>（1）在增强类上面添加注解@Order（数字类型值），数字类型值越小优先级越高。</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215303590.png" alt="img"></p>
<ul>
<li>类贴configuration和没有贴的区别，贴会被代理，这里还需要再去看看的</li>
</ul>
<p>@Configuration , @Component  都可作为配置类。</p>
<h2 id="4-spring常用注解"><a href="#4-spring常用注解" class="headerlink" title="4.spring常用注解"></a><strong>4.spring常用注解</strong></h2><p>但有区别： @Configuration 中 所有 带有 @Bean的注解都会被动态代理（CGLIB）， 因此对bean的调用返回的都是同一实例。@Component 没有被动态代理，每次调用返回的都是不同实例。</p>
<table>
<thead>
<tr>
<th>bean的注解</th>
<th><strong>@Component</strong> 组件，没有明确的角色</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Service</strong> 在业务逻辑层使用（service层</td>
<td></td>
</tr>
<tr>
<td><strong>@Repository</strong> 在数据访问层使用（dao层）</td>
<td></td>
</tr>
<tr>
<td><strong>@Controller</strong> 在展现层使用，控制器的声明（C）</td>
<td></td>
</tr>
<tr>
<td>@Autowired：由Spring提供注入bean</td>
<td></td>
</tr>
<tr>
<td>配置类注解</td>
<td>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置</td>
</tr>
<tr>
<td></td>
<td>@ComponentScan 用于对Component进行扫描</td>
</tr>
<tr>
<td>切面（AOP）相关注解</td>
<td><strong>Aspect</strong> 声明一个切面（类上） <strong>@After</strong> 在方法执行之后执行（方法上） <strong>@Before</strong> 在方法执行之前执行（方法上） <strong>@Around</strong> 在方法执行之前与之后执行（方法上）</td>
</tr>
<tr>
<td>@Value注解</td>
<td><strong>@Value</strong> 为属性注入值</td>
</tr>
</tbody></table>
<h2 id="5-JdbcTemplate（概念和准备）"><a href="#5-JdbcTemplate（概念和准备）" class="headerlink" title="5 JdbcTemplate（概念和准备）"></a><strong>5 JdbcTemplate（概念和准备）</strong></h2><h3 id="1、什么是JdbcTemplate"><a href="#1、什么是JdbcTemplate" class="headerlink" title="1、什么是JdbcTemplate"></a><strong>1、什么是JdbcTemplate</strong></h3><p>（1）Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库的操作</p>
<h3 id="2、准备工作"><a href="#2、准备工作" class="headerlink" title="2、准备工作"></a><strong>2、准备工作</strong></h3><p>（1）引入相关的jar包</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215310986.png" alt="img"></p>
<p>（2）在spring配置文件中配置连接池</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215315310.png" alt="img"></p>
<p>（3）配置JdbcTemplate对象，注入DataSource</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215321111.png" alt="img"></p>
<p>（4）创建service类，常见dao类，在dao注入jdbcTemplate对象</p>
<p>配置文件中</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215326037.png" alt="img"></p>
<p>Service</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215329336.png" alt="img"></p>
<p>Dao</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215334694.png" alt="img"></p>
<h3 id="4-1-JdbcTemplate数据库操作添加"><a href="#4-1-JdbcTemplate数据库操作添加" class="headerlink" title="4.1 JdbcTemplate数据库操作添加"></a><strong>4.1 JdbcTemplate数据库操作添加</strong></h3><p>1、对应数据库表创建实体类</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215338384.png" alt="img"></p>
<p>2、编写service和dao</p>
<p>（1）在dao里面进行添加数据的操作</p>
<p>（2）调用JdbcTemplate对象里面update方法实现添加操作</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215343062.png" alt="img"></p>
<p>有两个参数</p>
<p>第一个参数：sql语句</p>
<p>第二个参数：可变参数，设置sql语句值</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215346389.png" alt="img"></p>
<p>3、测试类</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215350101.png" alt="img"></p>
<h3 id="4-2-JdbcTemplate操作数据库（修改和删除）"><a href="#4-2-JdbcTemplate操作数据库（修改和删除）" class="headerlink" title="4.2 JdbcTemplate操作数据库（修改和删除）"></a><strong>4.2 JdbcTemplate操作数据库（修改和删除）</strong></h3><p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215353445.png" alt="img"></p>
<h3 id="4-3-JdbcTemplate操作数据库（查询返回某个值）"><a href="#4-3-JdbcTemplate操作数据库（查询返回某个值）" class="headerlink" title="4.3 JdbcTemplate操作数据库（查询返回某个值）"></a><strong>4.3 JdbcTemplate操作数据库（查询返回某个值）</strong></h3><p>1、查询表里面有多少条记录， 返回某个值</p>
<p>2、使用JdbcTemplate实现查询返回某个值代码</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215402286.png" alt="img"></p>
<p>有两个参数</p>
<p>第一个参数:sql语句</p>
<p>第二个参数：返回类型</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215405537.png" alt="img"></p>
<h3 id="4-4-JdbcTemplate操作数据库（查询返回对象）"><a href="#4-4-JdbcTemplate操作数据库（查询返回对象）" class="headerlink" title="4.4 JdbcTemplate操作数据库（查询返回对象）"></a><strong>4.4 JdbcTemplate操作数据库（查询返回对象）</strong></h3><p>1、场景：查询图书详情</p>
<p>2、JdbcTemplate实现返回对象</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215409750.png" alt="img"></p>
<p>方法中三个参数</p>
<p>第一个参数：sql语句</p>
<p>第二个参数：RowMapper，是接口，返回不同类型的数据，使用这个接口里面的实现类完成数据封装</p>
<p>第三个参数：sql语句值</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215412685.png" alt="img"></p>
<h3 id="4-5-JdbcTemplate操作数据库（查询返回集合）"><a href="#4-5-JdbcTemplate操作数据库（查询返回集合）" class="headerlink" title="4.5 JdbcTemplate操作数据库（查询返回集合）"></a><strong>4.5 JdbcTemplate操作数据库（查询返回集合）</strong></h3><p>1、场景：查询图书列表分页</p>
<p>2、调用JdbcTemplate方法实现返回集合</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215416740.png" alt="img"></p>
<p>方法中三个参数</p>
<p>第一个参数：sql语句</p>
<p>第二个参数：RowMapper，是接口，返回不同类型的数据，使用这个接口里面的实现类完成数据封装</p>
<p>第三个参数：sql语句值</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215419685.png" alt="img"></p>
<h3 id="4-6-JdbcTemplate操作数据库（批量操作）"><a href="#4-6-JdbcTemplate操作数据库（批量操作）" class="headerlink" title="4.6 JdbcTemplate操作数据库（批量操作）"></a><strong>4.6 JdbcTemplate操作数据库（批量操作）</strong></h3><p>1、批量操作：操作表里面有多条记录</p>
<p>2、JdbcTemplate实现批量操作</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215423636.png" alt="img"></p>
<p>有两个参数</p>
<p>第一个参数：sql语句</p>
<p>第二个参数：List集合，添加多条记录数据</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215426948.png" alt="img"></p>
<p>测试</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215430183.png" alt="img"></p>
<h3 id="4-7-JdbcTemplate操作数据库（批量修改）"><a href="#4-7-JdbcTemplate操作数据库（批量修改）" class="headerlink" title="4.7 JdbcTemplate操作数据库（批量修改）"></a><strong>4.7 JdbcTemplate操作数据库（批量修改）</strong></h3><p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215434484.png" alt="img"></p>
<p>测试</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215437437.png" alt="img"></p>
<h2 id="6-事务概念"><a href="#6-事务概念" class="headerlink" title="6. 事务概念"></a><strong>6. 事务概念</strong></h2><h3 id="6-1-什么是事务"><a href="#6-1-什么是事务" class="headerlink" title="6.1 什么是事务"></a><strong>6.1 什么是事务</strong></h3><p>（1）事务是数据库操作的最基本单元，逻辑上的一组操作，要么都成功，如果有一个失败所有操作都失败。</p>
<p>（2）典型场景：银行转账</p>
<p>lucy 转账100元给mary</p>
<p>lucy少100，mary多100</p>
<h3 id="6-2-事务四个特性（ACID）"><a href="#6-2-事务四个特性（ACID）" class="headerlink" title="6.2 事务四个特性（ACID）"></a><strong>6.2 事务四个特性（ACID）</strong></h3><p>（1）原子性</p>
<p>（2）一致性</p>
<p>操作之前和操作之后总量是不变的</p>
<p>（3）隔离性</p>
<p>多事务操作的时候，事务之间不产生影响</p>
<p>（4）持久性</p>
<p>事务进行提交以后，表中的数据真的发生变化</p>
<h3 id="6-3-事务操作（搭建事务操作环境）"><a href="#6-3-事务操作（搭建事务操作环境）" class="headerlink" title="6.3 事务操作（搭建事务操作环境）"></a><strong>6.3 事务操作（搭建事务操作环境）</strong></h3><p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215442300.png" alt="img"></p>
<p>1、创建数据库表，添加记录</p>
<p>2、创建service，搭建dao，完成对象创建和注入关系</p>
<p>（1）在service中注入dao，在dao中注入JdbcTemplate，在JdbcTemplate中注入DataSource</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215445901.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215449039.png" alt="img"></p>
<p>3、在dao里创建两个方法，多钱和烧钱的方法，在service创建方法（转账的方法）</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215452483.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215455154.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215458232.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215501483.png" alt="img"></p>
<p>4、上面代码，如果正常执行是没有问题的，但是如果代码执行过程中产生了异常</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215505332.png" alt="img"></p>
<p>（1）上面问题如何解决呢？</p>
<p>使用事务来解决</p>
<p>（2）事务操作的过程</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215509414.png" alt="img"></p>
<h3 id="6-4-事务操作（Spring事务管理介绍）"><a href="#6-4-事务操作（Spring事务管理介绍）" class="headerlink" title="6.4 事务操作（Spring事务管理介绍）"></a><strong>6.4 事务操作（Spring事务管理介绍）</strong></h3><p>1、事务添加到JavaEE三层结构里面Service层（业务逻辑层）</p>
<p>2、在Spring进行事务到管理操作</p>
<p>（1）两种方式：编程式事务管理和声明式事务管理（使用）</p>
<p>3、使用声明式事务管理</p>
<p>（1）基于注解方式</p>
<p>（2）基于xml配置文件方式</p>
<p>4、在Spring进行声明式事务管理，底层使用AOP</p>
<p>5、Spring事务管理API</p>
<p>（1）提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215513055.png" alt="img"></p>
<h3 id="6-5-事务操作（注解声明式事务管理）"><a href="#6-5-事务操作（注解声明式事务管理）" class="headerlink" title="6.5 事务操作（注解声明式事务管理）"></a><strong>6.5 事务操作（注解声明式事务管理）</strong></h3><p>1、在spring：配置文件配置事务管理器</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215519246.png" alt="img"></p>
<p>2、在spring配置文件，开启事务注解</p>
<p>（1）在spring配置文件中引入名称空间tx</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215522635.png" alt="img"></p>
<p>(2)开启事务注解</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215526183.png" alt="img"></p>
<p>3、在service类上面（获取service类里面方法上面添加事务注解）</p>
<p>（1）@Transactional，这个注解可以添加到类上面，也可以添加到方法上面</p>
<p>（2）如果把这个注解添加到类上面，这个类里面所有的方法都添加事务</p>
<p>（3）如果把这个注解添加方法上面，为这个方法添加事务</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215528881.png" alt="img"></p>
<h3 id="6-6-事务操作（声明式事务管理参数配置）"><a href="#6-6-事务操作（声明式事务管理参数配置）" class="headerlink" title="6.6 事务操作（声明式事务管理参数配置）"></a><strong>6.6 事务操作（声明式事务管理参数配置）</strong></h3><p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215533258.png" alt="img"></p>
<p>2、propagation：事务传播行为</p>
<p>当一个事务的方法被另外一个事务方法调用的时候，这个事务方法该如何进行处理</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215536850.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215543036.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215547682.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215551181.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215556831.png" alt="img"></p>
<p>3、ioslation：事务隔离级别</p>
<p>（1）事务有特性成为隔离型，多事务操作之间不会产生影响。不考虑隔离型会产生很多问题。解决事务的隔离型</p>
<p>（2）有三个问题：脏读、不可重复读、虚（幻）读</p>
<p>（3）脏读：一个未提交的事务读取到类另一个未提交事务的数据</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215602282.png" alt="img"></p>
<p>（4）不可重复读：一个未提交事务读取到另一提交事务修改数据</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215605759.png" alt="img"></p>
<p>（5）虚读：一个未提交事务读取到另一提交事务添加数据</p>
<p>（6）通过设置事务的隔离级别，解决读的问题</p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215608544.png" alt="img"></p>
<p><img src="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106215611950.png" alt="img"></p>
<p>mysql默认的事务隔离级别是可重复读</p>
<p>4、timeout:超时时间</p>
<p>（1）事务需要在一定的时间内进行提交，如果不提交进行回</p>
<p>5、readOnly:是否只读</p>
<p>(1)读：查询操作，写：添加修改删除操作</p>
<p>（2）readOnly:默认值false,表示可以查询，可以添加修改删除操作</p>
<p>（3）设置readOnly值是true，设置成true之后，只能查询</p>
<p>6、rollbackFor：回滚</p>
<p>（1）设置出现哪些异常进行事务回滚</p>
<p>7、noRollbackFor:不回滚</p>
<p>（1）设置出现异常不进行事务回滚</p>
<p>事务操作（xml声明式事务管理）</p>
<p>1、在spring的配置文件中进行配置</p>
<p>2、配置通知</p>
<p>3、配置切入点和切面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cla5f45s40000xjqk2qb321qv" data-title="Spring 学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot-从0到1搭建项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2022-11-06T13:28:44.000Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/">SpringBoot 从0到1搭建项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>SpringBoot从0到1搭建项目</strong></p>
<p>本次进行了使用springboot框架从0到1搭建项目</p>
<p>采用两种方法整合数据，对数据进行增加、删除、修改、查询操作</p>
<p>分别是jdbcTemplate方法、mybatis方法</p>
<p>最后对两种方法的使用分别进行了思考总结和区别的整理</p>
<p>本次学习新人可以按照这个教程傻瓜式学习，可以完成2个实战的demo</p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a><strong>1. 环境</strong></h2><p>环境安装，由于在staging环境下建立表需要权限，所以我在自己本地连接数据库和表进行操作。</p>
<table>
<thead>
<tr>
<th>去官网下载安装包</th>
<th>安装完成后在偏好设置找到</th>
<th>开启数据库服务</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212916864.png" alt="img"></td>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212922055.png" alt="img"></td>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212927630.png" alt="img"></td>
</tr>
</tbody></table>
<h2 id="2-jdbcTemplate方法"><a href="#2-jdbcTemplate方法" class="headerlink" title="2. jdbcTemplate方法"></a><strong>2. jdbcTemplate方法</strong></h2><p>首先介绍采用jdbcTemplate的方法操作数据库的实战步骤</p>
<h3 id="2-1-pom文件引入必要的依赖"><a href="#2-1-pom文件引入必要的依赖" class="headerlink" title="2.1 pom文件引入必要的依赖"></a><strong>2.1 pom文件引入必要的依赖</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;	</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springboot-jdbcTemplate&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;springboot-jdbcTemplate&lt;/name&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;8.0.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<h3 id="2-2-编写application-propoties，"><a href="#2-2-编写application-propoties，" class="headerlink" title="2.2 编写application.propoties，"></a><strong>2.2 编写application.propoties，</strong></h3><p>这个必须这样来配置，是固定的配置，不要自己出新花样，就按照我这个来进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/aauser?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=12345678</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>





<h3 id="2-3-创建实体类"><a href="#2-3-创建实体类" class="headerlink" title="2.3 创建实体类"></a><strong>2.3 创建实体类</strong></h3><p>实体类，顾名思义，这里要和数据库表进行完全的对应</p>
<p>具体的编码详情如User类所示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212935395.png" alt="img"></p>
<h3 id="2-4-在service层定义接口"><a href="#2-4-在service层定义接口" class="headerlink" title="2.4 在service层定义接口"></a><strong>2.4 在service层定义接口</strong></h3><p>定义好需要的增删改查的方法，在UserService中先定义好需要操作数据库的方法</p>
<p>具体的编码详情如UserService所示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212939426.png" alt="img"></p>
<h3 id="2-5-在UserServiceImpl里实现方法"><a href="#2-5-在UserServiceImpl里实现方法" class="headerlink" title="2.5 在UserServiceImpl里实现方法"></a><strong>2.5 在UserServiceImpl里实现方法</strong></h3><p>通过在具体的实现类去写sql语句，实现具体的方法</p>
<p>具体的编码详情如UserServiceImpl所示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212943925.png" alt="img"></p>
<h3 id="2-6-实现效果"><a href="#2-6-实现效果" class="headerlink" title="2.6 实现效果"></a><strong>2.6 实现效果</strong></h3><table>
<thead>
<tr>
<th>增加</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212948135.png" alt="img"></td>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212951295.png" alt="img"></td>
</tr>
<tr>
<td>删除表中全部数据</td>
<td></td>
</tr>
<tr>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212956401.png" alt="img"></td>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106212959476.png" alt="img"></td>
</tr>
<tr>
<td>修改</td>
<td>因为本来都删除了，先增加了一条数据，然后修改</td>
</tr>
<tr>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213002804.png" alt="img"></td>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213006731.png" alt="img"></td>
</tr>
<tr>
<td>查询</td>
<td>在控制台打印出数据库的这一条数据</td>
</tr>
<tr>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213010373.png" alt="img"></td>
<td><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213013989.png" alt="img"></td>
</tr>
</tbody></table>
<h3 id="2-7-思考"><a href="#2-7-思考" class="headerlink" title="2.7 思考"></a><strong>2.7 思考</strong></h3><p>JDBCTemplate</p>
<p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，使用者只需自己注入即可使用。</p>
<p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>
<p>JdbcTemplate主要提供以下几类方法：</p>
<p>1、execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</p>
<p>2、update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</p>
<p>3、query方法及queryForXXX方法：用于执行查询相关语句；</p>
<h2 id="3-mybatis方法"><a href="#3-mybatis方法" class="headerlink" title="3. mybatis方法"></a><strong>3. mybatis方法</strong></h2><p>使用springboot的mybatis方法进行数据库的CURD操作的实战具体步骤</p>
<h3 id="2-1-导入-MyBatis-所需要的依赖"><a href="#2-1-导入-MyBatis-所需要的依赖" class="headerlink" title="2.1 导入 MyBatis 所需要的依赖"></a><strong>2.1 导入 MyBatis 所需要的依赖</strong></h3><p>已经装好数据库，直接开始配置</p>
<p>这个也是要导入必备的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<h3 id="2-2-配置数据库连接信息"><a href="#2-2-配置数据库连接信息" class="headerlink" title="2.2 配置数据库连接信息"></a><strong>2.2 配置数据库连接信息</strong></h3><p>这里必须按照这样进行配置，是固定的写法，基本的数据库连接信息因人而异</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapping/*Mapper.xml</span><br><span class="line">  type-aliases-package: com.example.entity</span><br><span class="line">#showSql</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com:</span><br><span class="line">      example:</span><br><span class="line">        mapper : debug</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 12345678</span><br><span class="line">    url: jdbc:mysql://localhost:3306/aauser?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  thymeleaf:</span><br><span class="line">    cache: false</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br><span class="line">    encoding: utf-8</span><br><span class="line">    mode: html5</span><br><span class="line">    content-type: text/html</span><br></pre></td></tr></table></figure>





<h3 id="2-3-创建实体类-1"><a href="#2-3-创建实体类-1" class="headerlink" title="2.3 创建实体类"></a><strong>2.3 创建实体类</strong></h3><p>导入 Lombok，同样定义了User的实体类</p>
<p>具体的编码详情如User类所示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213020577.png" alt="img"></p>
<h3 id="2-4-创建mapper目录以及对应的-Mapper-接口"><a href="#2-4-创建mapper目录以及对应的-Mapper-接口" class="headerlink" title="2.4 创建mapper目录以及对应的 Mapper 接口"></a><strong>2.4 创建mapper目录以及对应的 Mapper 接口</strong></h3><p>然后定义了UserMapper接口</p>
<p>具体的编码详情如UserMapper接口所示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213024333.png" alt="img"></p>
<h3 id="2-5-对应的Mapper映射文件"><a href="#2-5-对应的Mapper映射文件" class="headerlink" title="2.5 对应的Mapper映射文件"></a><strong>2.5 对应的Mapper映射文件</strong></h3><p>在xml文件中去实现映射的关系</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213029422.png" alt="img"></p>
<h3 id="2-6实现userMapper的调用"><a href="#2-6实现userMapper的调用" class="headerlink" title="2.6实现userMapper的调用"></a><strong>2.6实现userMapper的调用</strong></h3><p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213032193.png" alt="img"></p>
<h3 id="2-7-实现"><a href="#2-7-实现" class="headerlink" title="2.7 实现"></a><strong>2.7 实现</strong></h3><p>实现数据增加</p>
<p>代码</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213035572.png" alt="img"></p>
<p>增加效果展示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213038371.png" alt="img"></p>
<p>实现对数据按照id删除</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213041572.png" alt="img"></p>
<p>删除效果展示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213044834.png" alt="img"></p>
<p>实现对数据按照id修改</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213048496.png" alt="img"></p>
<p>对数据按照id修改</p>
<p>效果展示</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213052400.png" alt="img"></p>
<p>对数据进行查询，并在控制台打印出查询结果</p>
<p><img src="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/out-20221106213055685.png" alt="img"></p>
<h3 id="2-8-思考"><a href="#2-8-思考" class="headerlink" title="2.8 思考"></a><strong>2.8 思考</strong></h3><p>mybatis是一个支持普通sql查询存储过程的持久层框架,有了mybatis,应用程序将不再访问底层数据库，以面向对象的方式来操作持久层对象。 它不需要专门创建一个类来实现业务的具体操作，配置也比spring jdbc简单了许多，只需要在映射文件中配置一些基本sql语句实现业务，而且代码量少</p>
<h2 id="4-总结："><a href="#4-总结：" class="headerlink" title="4. 总结："></a><strong>4. 总结：</strong></h2><p>Mybatis映射文件相当于jdbc上面的实现类。映射文件只需要几行来创建业务，而实现类需要大量的代码来实现几个简单的业务，这大大增加了开发者的工作量，降低了效率。</p>
<p>所以综合来看，mybatis在开发过程中常用到的工具，比基本的jdbc更加方便简练，不容易出错，大大提升了开发的效率。</p>
<p>通过本次学习，对于对数据库的操作的一些操作更加了解了，之后打算再对数据库的语句的基础进行一个补充的复习。</p>
<p>同时对springboot从0到1搭建项目有了初步的了解，之后可以继续了解springboot的其他特性</p>
<p>不足之处是，虽然使用起来觉得比较精妙，但是还不太理解这样去设计的底层实现，这个需要后面逐步加深理解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/" data-id="cla5e7vet0000wuqkdfua2tcu" data-title="SpringBoot 从0到1搭建项目" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RPC学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-11-06T13:23:04.000Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">RPC学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>咱们来浅浅谈一下GRPC</strong></p>
<h2 id="1-What：RPC是什么"><a href="#1-What：RPC是什么" class="headerlink" title="1.  What：RPC是什么"></a><strong>1.  What：RPC是什么</strong></h2><p>RPC的语义是远程过程调用，（英语：Remote Procedure Call，缩写为RPC）就是将一个服务调用封装在一个本地方法中，让调用者像使用本地方法一样调用服务，对其屏蔽实现细节。RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行消息交互的系统。</p>
<p><img src="/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106212415971-7741058.png" alt="img"></p>
<p>​	如图所示，RPC是一个基于一个大大内部服务，进行分布式拆分，由于其语义上以本地方法的作为入口，那么天然就更加倾向于具备高性能、支持复杂参数和返回值、跨语言等特性。</p>
<h2 id="2-What：GRPC是什么？"><a href="#2-What：GRPC是什么？" class="headerlink" title="2. What：GRPC是什么？"></a><strong>2. What：GRPC是什么？</strong></h2><p>gRPC是一种现代化开源的高性能RPC框架，能够运行于任意环境中，最初是由谷歌进行开发。使用HTTP&#x2F;2作为传输协议。</p>
<p>在gRPC里，客户端可以像调用本地方法一样直接调用其他及其上的服务端应用程序的方法，帮助你更加容易创建分布式应用程序和服务。与许多RPC系统一样，gRPC是基于定义一个服务，指定一个可以远程调用的带有参数和返回类型的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用，在客户端有一个代理提供和服务端相同的方法。</p>
<p><img src="/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out-20221106212424258-7741068.png" alt="img"></p>
<h3 id="2-1-GRPC的特点"><a href="#2-1-GRPC的特点" class="headerlink" title="2.1 GRPC的特点"></a><strong>2.1 GRPC的特点</strong></h3><p>1、google开源的一款RPC框架</p>
<p>2、基于HTTP&#x2F;2之上的二进制协议，并发处理多个请求和相应</p>
<p>3、一个连接上可以多路复用，并发处理多个请求和相应</p>
<p>4、具备多种语言的类库实现；</p>
<p>5、服务定义文件和自动代码生成（.proto文件和Protobuf编译工具）</p>
<h2 id="3-Why：为什么要用gRPC"><a href="#3-Why：为什么要用gRPC" class="headerlink" title="3. Why：为什么要用gRPC?"></a><strong>3. Why：为什么要用gRPC?</strong></h2><p>使用gRPC，可以一次性的在一个.proto文件中定义服务并使用任何支持它的语言去实现客户端和服务端。反过来，它们可以应用在各种场景中，从Google的服务器到你自己的平板电脑。起初，服务大多都是单体服务，随着业务规模逐渐扩大，之前的单体服务不得不面临拆分，而由单体服务拆分成微服务带来的一个问题就是服务之间的网络通信数量不断增加，虽然服务变微了，但是网络连接数却有变多了。</p>
<p>gRPC客户端和服务端可以在各种环境中运行和互相通信–甚至是从Google内部的服务器到个人的计算机桌面，并且可以用任何gRC支持的语言编写。因此，可以使用Go、Python或者Ruby中的客户端轻松地创建gRPC服务器。gRPC帮你解决了不同语言及环境间通信的复杂性。使用protocol buffers还能获得其他好处，包括高效的序列号，总之一句话，使用gRPC能让我们更加容易编写跨语言的分布式代码。</p>
<p>但是，gRPC最大的优势是支持流式传输。</p>
<h2 id="4-How：使用ProtoBuf组织内容"><a href="#4-How：使用ProtoBuf组织内容" class="headerlink" title="4. How：使用ProtoBuf组织内容"></a><strong>4. How：使用ProtoBuf组织内容</strong></h2><p>因为RPC需要约定调用语法，需要约定内容编码方式，需要网络传输协议，RPC框架围绕这几方面不断进行优化，所以在内容编码方面，RPC调用的request和response内容在调用过程中有着不小的消耗。主要的消耗体现在这两方面：</p>
<ul>
<li>内容的序列化、反序列化，如果效率更高，则对CPU的消耗会更小</li>
<li>内容会在网络中传输，协议栈拷贝成本，带宽成本，GC等，体积越小，效率越高。</li>
</ul>
<p>使用RPC框架有如下几个目标：</p>
<ul>
<li>尽可能快的序列化、反序列化</li>
<li>序列化后的体积越小越好</li>
<li>跨语言，和语言无关</li>
<li>简单、类型准确</li>
<li>易扩展，可以简单的迭代，向后兼容</li>
</ul>
<p>如何序列化和检索结构化数据？有几种方法可以解决。</p>
<p>1、使用Java序列化，这是默认使用方法，因为它在内置在语言中，但是它有许多众所周知的问题。</p>
<p>2、可以发明一种特殊的方法将数据项编码为单个字符串，例如将四个整数编码为”12:3:-23:67”。这是一种简单又灵活的方法，尽管它确实需要编写一次性的编码和解析代码。</p>
<p>3、将数据序列化为xml，这种方法可能非常有吸引力，因为xml(某种程度)是人类可读的，并且有许多语言的绑定库。但是对xml进行编码会对应用程序造成巨大的性能损失。</p>
<p>综上所诉，使用 Protocol Buffers，是Google开发的一种跨语言、跨平台、可扩展的用于序列化数据协议。通过编写.proto要存储的数据结构的描述，protocol buffer编译器会创建一个类，该类以高效的二进制格式实现protocol buffer数据的自动编码和解析。生成的类为组成协议缓冲区的字段提供getter和setter，并将读取和写入协议缓冲区的细节作为处理单元。</p>
<h3 id="4-1-定义protobuf"><a href="#4-1-定义protobuf" class="headerlink" title="4.1 定义protobuf"></a><strong>4.1 定义protobuf</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//第一行指定了正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">//.proto文件以包声明开头，有助于防止不同项目之间的命名冲突。在java中，包名称用作Java包。</span><br><span class="line">package kuaishou.merchant.financial.seller;</span><br><span class="line"></span><br><span class="line">import &quot;merchant_financial_common.proto&quot;;</span><br><span class="line">import &quot;identity/merchant_financial_identity.proto&quot;;</span><br><span class="line"></span><br><span class="line">//可以生成单独的.java，每个生成的类的文件（而不是为包装类生成单个.java文件，使用包装类作为外部类并将所有其他类嵌套在包装类中的传统行为）。</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">//指定生成的类应该使用什么Java包名称，如果没有明确指定，只会匹配package声明给出的包名，但是这些名称通常不是合适的Java包名。</span><br><span class="line">option java_package = &quot;com.kuaishou.protobuf.plateco.merchant.financial.biz&quot;;</span><br><span class="line">//将代表此文件的包装类的类名。如果没有明确给出，通过将文件名转换成大写驼峰的形式。</span><br><span class="line">option java_outer_classname = &quot;MerchantFinancialOrderQueryInvoiceServiceProto&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-定义消息"><a href="#4-2-定义消息" class="headerlink" title="4.2 定义消息"></a><strong>4.2 定义消息</strong></h3><p>消息是包含一组类型字段的聚合，简单的数据类型可以用作字段类型，包括bool、int32、float、double和string。也可以使用其他消息类型作为字段类型来为消息添加进一步的结构。每个元素的“&#x3D;1”、“&#x3D;2”标记标识该字段在二进制编码中使用的唯一“标签”。标签1-15比更高的编号需要少一个字节来编码，因此作为一种优化，可以决定激昂这些标签用于常用或者重复的元素，而将标签16和更高的标签用于不太常用的可选元素。重复字段中的每一个元素都需要重新编码标签号，因此重复字段特别适合这种优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">message PcScrollGetOrderListForInvoiceRequest &#123;</span><br><span class="line">  //商家ID</span><br><span class="line">  int64 seller_id = 1;</span><br><span class="line">  //结算主体</span><br><span class="line">  string platform_commission_subject = 2;</span><br><span class="line">  //结算时间-下限</span><br><span class="line">  uint64 settlement_time_gte = 3;</span><br><span class="line">  //结算时间-上限</span><br><span class="line">  uint64 settlement_time_lte = 4;</span><br><span class="line">  //订单状态</span><br><span class="line">  uint32 order_status = 5;</span><br><span class="line">  //游标</span><br><span class="line">  string cursor = 6;</span><br><span class="line">  //  每页返回数量</span><br><span class="line">  uint32 size = 7;</span><br><span class="line">  //  角色,SELLER-商家，DISTRIBUTOR-分销者，ACTIVITY_USER-团长，KZK-快赚客</span><br><span class="line">  string role_type = 8;</span><br><span class="line">  bool if_exclude_v3_order = 20;</span><br><span class="line">  // 0 结算后退款 1 超售后期</span><br><span class="line">  int32 refund_type = 10;</span><br><span class="line">  kuaishou.merchant.financial.identity.MerchantFinancialIdentityAuthDTO identity_auth_dto = 9;</span><br><span class="line">  int64 time_start = 11;</span><br><span class="line">  int64 time_end = 12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    optional string number = 1;</span><br><span class="line">    optional PhoneType type = 2 [default = HOME];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-定义枚举"><a href="#4-3-定义枚举" class="headerlink" title="4.3 定义枚举"></a><strong>4.3 定义枚举</strong></h3><p>可以通过enum定义枚举，如下代码块所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum AccountState &#123;</span><br><span class="line">  UNKNOWN_ACCOUNT_STATE = 0;</span><br><span class="line">  //正常</span><br><span class="line">  NORMAL = 1;</span><br><span class="line">  //出入款都冻结</span><br><span class="line">  FROZEN = 2;</span><br><span class="line">  //  只冻出款,入款正常</span><br><span class="line">  FROZEN_OUT = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每个字段都必须使用以下修饰符之一进行注释</p>
<ul>
<li>optional: 该字段可以设置也可以不设置。如果未设置可选字段值，则使用默认值。对于简单类型，可以指定自己的默认值，就像我们在示例中为电话号码所做的那样type。否则，使用系统默认值：数字类型为零，字符串为空字符串，布尔值为 false。对于嵌入式消息，默认值始终是消息的“默认实例”或“原型”，没有设置任何字段。调用访问器以获取未显式设置的可选（或必需）字段的值始终返回该字段的默认值。</li>
<li>repeated：该字段可以重复任意次数（包括零次）。重复值的顺序将保存在协议缓冲区中。将重复字段视为动态大小的数组。</li>
<li>required：必须提供该字段的值，否则该消息将被视为“未初始化”。尝试构建未初始化的消息将抛出RuntimeException. 解析未初始化的消息将抛出IOException. 除此之外，必填字段的行为与可选字段完全相同。</li>
</ul>
<p>⚠️注意：非常小心将字段标记为required。如果在某些时候希望停止编写或发送必填字段，则将该字段更改为可选字段将会有问题——老读者会认为没有此字段的消息不完整，可能会无意中拒绝或丢弃它们。您应该考虑为您的缓冲区编写特定于应用程序的自定义验证例程。在 Google 内部，required字段是非常不受欢迎的；proto2 语法中定义的大多数消息optional仅使用repeated。（Proto3 根本不支持required字段。）</p>
<h3 id="4-4-代码规范方面"><a href="#4-4-代码规范方面" class="headerlink" title="4.4 代码规范方面"></a><strong>4.4 代码规范方面</strong></h3><h4 id="4-4-1-消息体和字段名称"><a href="#4-4-1-消息体和字段名称" class="headerlink" title="4.4.1 消息体和字段名称"></a><strong>4.4.1 消息体和字段名称</strong></h4><p>使用 CamelCase（首字母大写）作为消息名称 - 例如，SongServerRequest. 使用 underscore_separated_names 作为字段名称（包括 oneof 字段和扩展名）——例如，song_name.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SongServerRequest &#123;</span><br><span class="line">  optional string song_name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对重复的字段使用复数名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeated string keys = 1;</span><br><span class="line">  ...</span><br><span class="line">  repeated MyMessage accounts = 17;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-2-枚举类型名称"><a href="#4-4-2-枚举类型名称" class="headerlink" title="4.4.2 枚举类型名称"></a><strong>4.4.2 枚举类型名称</strong></h4><p>使用 CamelCase（首字母大写），每个枚举值都应该以分号结尾，而不是逗号。更喜欢为枚举值添加前缀，而不是将它们包围在封闭的消息中。零值枚举应该有后缀UNSPECIFIED。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum FooBar &#123;</span><br><span class="line">  FOO_BAR_UNSPECIFIED = 0;</span><br><span class="line">  FOO_BAR_FIRST_VALUE = 1;</span><br><span class="line">  FOO_BAR_SECOND_VALUE = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-3-服务"><a href="#4-4-3-服务" class="headerlink" title="4.4.3 服务"></a><strong>4.4.3 服务</strong></h4><p>如果.proto定义了一个 RPC 服务，您应该使用 CamelCase（首字母大写）作为服务名称和任何 RPC 方法名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service FooService &#123;</span><br><span class="line">  rpc GetSomething(GetSomethingRequest) returns (GetSomethingResponse);</span><br><span class="line">  rpc ListSomething(ListSomethingRequest) returns (ListSomethingResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-4-构建器与消息"><a href="#4-4-4-构建器与消息" class="headerlink" title="4.4.4 构建器与消息"></a><strong>4.4.4 构建器与消息</strong></h4><p>协议缓冲区编译器生成的消息类都是不可变的。消息对象一旦被构造，就不能被修改。要构造消息，必须先构造一个构建器，将要设置的任何字段设置为选择的值，然后调用构建器的build()方法。</p>
<p>修改消息的构建器的每个方法都会返回另一个构建器。返回的对象实际上是您调用该方法的同一个构建器。它是为了方便而返回的，方便可以在一行代码中将多个 setter 串在一起。</p>
<p>以下是如何创建的实例的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueryDeductPursueByPageRequest queryDeductPursueByPageRequest = QueryDeductPursueByPageRequest.newBuilder()</span><br><span class="line">                    .setSellerId(sellerId)</span><br><span class="line">                    .setPage(page)</span><br><span class="line">                    .setSize(100)</span><br><span class="line">                    .setStatus(DeductPursueStatus.PAID)</span><br><span class="line">                    .setPayStartTime(begTime)</span><br><span class="line">                    .setPayEndTime(endTime)</span><br><span class="line">                    .setBizType(BizType.PLATFORM_DEDUCT_FINE_PLATFORM )</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>



<h2 id="5-总结gRPC的开发流程"><a href="#5-总结gRPC的开发流程" class="headerlink" title="5. 总结gRPC的开发流程"></a><strong>5. 总结gRPC的开发流程</strong></h2><p>一个完整的gRPC开发分为3步，最终实现让使用者面向接口编程。如图所示。</p>
<ol>
<li>编写.proto文件定义服务</li>
<li>生成指定语言的代码</li>
<li>编写业务逻辑的代码</li>
</ol>
<p><img src="/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/out.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cla5dzo690000m1qk4srnh58z" data-title="RPC学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-四个月工作总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/%E5%9B%9B%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-11-06T13:09:53.000Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/06/%E5%9B%9B%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">四个月工作总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/06/%E5%9B%9B%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" data-id="cla5dh6qv0000mxqk7l1746au" data-title="四个月工作总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4个月工作总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-11-05T19:51:52.000Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/06/4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">我的第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​	这是我的第一篇hexo博客，也是我工作后的第4个月啦。<strong>下周一就是我的生日了</strong>，就又长大一岁了，这个周末思考了很久，经历了一段时间的迷茫，下定决心做一些规划，也把自己从校园到初入职场的一些心得体会记录下来，给日后的自己看看，加油吧！</p>
<p><img src="/2022/11/06/4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/image-20221106210122842.png" alt="image-20221106210122842"></p>
<p>​	这是我入职的第一天在总部照的照片。赚到了人生的第一桶金，也吃了一些苦，同时开始规划自己将来的道路，我还是坚定的想要扎扎实实的打好技术基础，然后不愧于自己的初心，成为一个技术达人。我知道这注定是很难的一条道路，但是每次我问自己是否依然想要坚持下去，这个答案都无比坚定。</p>
<p>​	笃定的理想：入职4个月啦，在这段时间里，周围认识的人都很厉害都很优秀，无论是学历、能力、经验感觉很多方面自己多要去学习去努力。吃了不少没经验的苦头，遇到了不少的挫折–比如初入职场和学校的思维方式不同的不适应、比如独自一人在陌生的环境生活的孤独、比如工作中不顺手不知道怎么处理无人指点、比如精神压力比较大不知道怎么排解等等。有时候是自己悄悄的流眼泪，有时候找家人诉苦，有时候和同学聊天，但是总是觉得还比较迷茫。直到生日的前几天，终于想明白了，觉得自己不再迷茫了。在职场里，女程序猿终究是极其少的，男女比例是10:1，而对女程序猿的要求却丝毫没有打折扣的。很多职场里的同事告诉我，我的出路就是结婚嫁人，相夫教子。家里人跟我说，实在不行太累了，就回家考个公务员吧。我想了又想，自己总觉得别人说的种种都不是我想要的，我想：人生只有一次，总要做点什么事儿，不为任何人，只因为自己想做。我想看清楚这个世界，我想依靠我个人的力量为他人做点什么有帮助的事情，我想给我爱的人更好的生活，我想不依靠别人的力量，仅仅是自己就能成为爱的人的庇护。这似乎就是我心底笃定的理想，我想实现它，为之不停的努力奋斗。从我看清楚自己的内心以后，我不再迷茫了，因为只有我自己知道，现在的我：脑袋里盛着目标，拳头上蓄满力气，眼睛里闪烁星星。</p>
<p>​	乐观的心态：我想把我这4个月里对我影响比较大的片段记录下来，同时也提醒自己将来要成为怎样的人。事件一：初入职场的我，很多时候要向老同事请教一些问题，总是向人家请教我挺不好意思的，就请大家喝了奶茶以表谢意。但是却被老同事教训：你想喝奶茶自己买就好，给每个人都买，那我们每个人都要请你喝一杯奶茶吗？我们不会因为你买了奶茶就认可你，一瓶奶茶就10块8块的，要公私分明不要工作的时候给我们买奶茶这么买下去你工资都不够请我们喝奶茶的。教训我不要请奶茶，他却请别的同事喝奶茶。买雪糕没有给他带，他又说他要吃雪糕没给他。事件二：做的事情都是重复性的杂活，我想做一些更有挑战性的任务，主要积极要活，却被说成是挑活，曲解我的本意，说我情商低。事件三：每天都有在努力做好自己的事情，在没有和他交流的情况下，过来主动push我的进度（他也不是我领导，也不是带我的师父），我说我在研究，他还嘲笑我，不会给予你真正的帮助，就是想要冷嘲热讽你一下，似乎这样才能显示出来他有多么的了不起。事件四：因为我之前做过那个任务，踩过一些坑，然后有刚入职的同事要做相同的事情，我按照之前的经验想要给予善意的提醒，哪些是需要了解和对齐的，却被理解成“要你教我做事”，“跟你有什么关系”，热脸贴了冷屁股。通过这几件小事情，我的心态也在不断的调整，我明白在职场中，做好自己的事情，想要强，只有自己足够强大；我也明白在职场中和在学校不同，在学校里很平常的互相买雪糕和饮料，在职场中都会被别有用心的放大；明白了在职场中想要做更有挑战的任务，只能通过做一件件不起眼的小事情并做到极致，做到完美才有机会做其他的事情；明白了在职场中善良要有锋芒，善意要给对的人。</p>
<p>​	制定一个学习计划吧。想清楚了自己想要什么、想成为怎样的人，那么就努力去执行吧，现在自己的能力无法支撑自己的野心。我想，哪里不足就补充哪里，吃技术的饭，就需要技术足够强足够扎实，现在我已经入场，相当于和大家在同一个起点，3年后在哪里，取决于当下的每一天努力。我想把java基础扎扎实实的复习一遍，把springboot框架认真学习一遍，把消息队列熟悉清楚，把数据库mysql和redis搞熟练，把es搞明白，然后linux指令也需要积累做笔记。最后就是把自己的业务有时间就要梳理，整理，学习。先对业务再熟悉一点，从原来业务代码写都费劲，一点点熟悉业务代码，然后可以负责一个项目，最后可以负责一个方向的业务。因为我每天的工作时间比较长，所以我就不制定学习时间的计划，只是每天提醒自己，有时间就要学习，每天进行积累。学习了就写写文章进行记录，一定要坚持下去！</p>
<p>​	加油吧，小刘，即使再小的舟也能远航。向着你心目中的目标出发吧，过去的7年求学经历，才让自己走到了这里，那么就要加倍珍惜现在的一切，把自己磨练成一身的钢筋铁骨，学会一身的本领，然后成为一个善良、独立、乐于助人、有才华、富有的人吧哈哈哈！对，要富有哦！不只是物质富有还要精神富有！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/06/4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" data-id="cla4dkww80000qmqk9sa0bplp" data-title="我的第一篇博客" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/06/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-11-05T18:54:35.066Z" itemprop="datePublished">2022-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/06/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/06/hello-world/" data-id="cla4bu3ky0000n4qk0wamcdi7" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/06/Spring-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring 学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/11/06/SpringBoot-%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/">SpringBoot 从0到1搭建项目</a>
          </li>
        
          <li>
            <a href="/2022/11/06/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">RPC学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/11/06/%E5%9B%9B%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">四个月工作总结</a>
          </li>
        
          <li>
            <a href="/2022/11/06/4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">我的第一篇博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>